#pragma once

#include <nano/datasource.h>

namespace nano
{
///
/// \brief random dataset useful as a baseline or for testing.
///
/// NB: the feature values are generated by sampling from an uniform distribution (the seed is fixed, but configurable).
///
class NANO_PUBLIC random_datasource_t : public datasource_t
{
public:
    ///
    /// \brief constructor
    ///
    random_datasource_t(tensor_size_t samples, features_t, size_t target, tensor_mem_t<int8_t, 2> hits);

    ///
    /// \brief @see clonable_t
    ///
    rdatasource_t clone() const override;

    ///
    /// \brief return the hit map showing which feature values are given.
    ///
    const tensor_mem_t<int8_t, 2>& hits() const { return m_hits; }

protected:
    template <template <typename, size_t> class tstorage, typename tscalar, size_t trank>
    void set_fvalues(const tensor_size_t feature, const tensor_t<tstorage, tscalar, trank>& fvalues)
    {
        if constexpr (trank == 1)
        {
            for (tensor_size_t sample = 0; sample < m_samples; ++sample)
            {
                if (m_hits(sample, feature) != 0)
                {
                    set(sample, feature, fvalues(sample));
                }
            }
        }
        else
        {
            for (tensor_size_t sample = 0; sample < m_samples; ++sample)
            {
                if (m_hits(sample, feature) != 0)
                {
                    set(sample, feature, fvalues.tensor(sample));
                }
            }
        }
    }

    ///
    /// \brief @see datasource_t
    ///
    void do_load() override;

private:
    // attributes
    tensor_size_t           m_samples{0};
    features_t              m_features;
    size_t                  m_target{0U};
    tensor_mem_t<int8_t, 2> m_hits;
};
} // namespace nano
